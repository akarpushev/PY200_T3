# Свойства - методы, которые ведут себя как атрибуты.
# Свойство нечто среднее между атрибутом и методом.
# По синтаксису вызывается как атрибут, но содержит в себе логику как в методе.

class PropertyClass:

    @property
    def prop(self):
        """Геттер не принимает никаких агрументов, но должен возвращать какой-то результат."""
        return None

    @prop.setter
    def prop(self, value):
        """Сеттер принимает один агрумент, и не должен возвращать результат."""
        ...

# `prop` - название переменной свойства.

### Getter
#Свойство возвращает состояние какого-либо атрибута, который хотят спрятать от прямого доступа пользователя.
# Что бы метод стал свойством его необходимо задекорировать декоратором **`@property`**.
# И он сразу начинает вести себя как getter

@property
def prop(self):
    """Геттер не принимает никаких агрументов, но должен возвращать какой-то результат."""
    return None
### ***Важно***:
# - getter не принимает никаких аргументов
# - getter должен возвращать какой-то результат

# Если объявлен только getter, то свойство доступно **только на чтение** и пользователь не может изменить его значение.

class Book:
    def __init__(self, name: str):
        self.name = name  # TODO сделать атрибут защищенным

    # TODO написать свойство для name

book = Book("Букварь")
print(book.name)  # вызов getter свойства

# TODO попробовать установить значение свойству

class Book:
    def __init__(self, name: str):
        self._name = name  # инициализируем защищенный атрибут

    @property
    def name(self):
        """Геттер не принимает никаких агрументов, но должен возвращать какой-то результат."""
        return self._name  # внутри класса обращаемся к защищенному атрибуту

book = Book("Букварь")
print(book.name)  # вызов getter свойства


### Setter
#Setter изменяет состояние какого-либо атрибута, который хотят спрятать от прямого доступа пользователя.
# Чтобы у свойства появился setter метод нужно задекорировать декоратором @<property_name>.setter.

@property
def prop(self):
    """Геттер не принимает никаких агрументов, но должен возвращать какой-то результат."""
    return None

@prop.setter
def prop(self, value):
    """Сеттер принимает один агрумент, и не должен возвращать результат."""
    ...

### Важно:
# setter принимает один аргумент
# setter не должен возвращать какой-то результат
# Нельзя объявить один setter.
# Setter может существовать только совместно с getter.
# Также setter и getter должны называться одинаково.


class Book:
    def __init__(self, pages: int):
        self.pages = pages  # отработает setter свойства!

    # вместо get_pages используется метод pages и @property
    @property
    def pages(self) -> int:
        """Возвращает количество страниц в книге."""
        return self._pages

    # вместо set_pages используется метод pages и @pages.setter
    @pages.setter
    def pages(self, new_pages: int) -> None:
        """Устанавливает количество страниц в книге."""
        if not isinstance(new_pages, int):
            raise TypeError("Количество страниц должно быть типа int")
        if new_pages <= 0:
            raise ValueError("Количество страниц должно быть положительным числом")
        self._pages = new_pages

book = Book(200)
print(book.pages)  # вызываем как атрибут, но срабатывает метод
book.pages = 300  # присваиваем значение атрибуту, но срабатывает метод
print(book.pages)

### Применение свойств
# Первое применение свойст - это сделать атрибут только для чтения (read-only),
# объявив только getter.
# Второе и пожалуй более важное.
# При переходе от публичных атрибутов к защищенным, нам пришлось переименовывать атрибуты внутри класса это раз,
# два а вдруг, кто-то вне нашего класса уже пользовался атрибутами, а мы их закрыли((
# Так вот свойства, помимо сокрытия и навешивания дополнительной логики,
# позволяют сделать реализацию класса сначала с атрибутами, а потом по мере необходимости переходить к свойствам.
# При этом внутренние изменения нашего класса абсолютно прозрачны для всех сущностей с которыми он взаимодействует
# (при учете того, что всё реализовано корректно:))).
# Атрибут не переименован и вызывается также.
# Чуть глубже с устройством свойств можно ознакомиться здесь (https://way23.ru/python-%D1%81%D0%B2%D0%BE%D0%B9%D1%81%D1%82%D0%B2%D0%B0/)

### Выводы
# В языке Python к непубличным переменным доступ разрешён.
# В языке Python Вы в любом случаем сможете изменить непубличные атрибуты.
# В языке Python вы просто предоставляете информацию пользователю
# разработанного Вами класса, что данный атрибут предназначен только для
# внутренней инфраструктуры класса.
# Вы не гарантируете, что непубличные атрибуты могут измениться
# в следующей версии вашего кода.
# Инкапсулируйте все, что может изменяться.
# Свойства - методы, которые ведут себя как атрибуты.
# Свойство-сеттер определяется после свойства-геттера.
# Сеттер, и геттер называются одинаково
# Что к геттеру, что к сеттеру, обращаемся как к атрибуту.